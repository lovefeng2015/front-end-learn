/*
 * @Author: yhf 
 * @Date: 2021-11-Mo 07:42:54 
 * @Last Modified by:   yhf 
 * @Last Modified time: 2021-11-Mo 07:42:54 
 */


/**
 * 剑指 Offer 56 - I. 数组中数字出现的次数
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
 * @param {number[]} nums
 * @return {number[]}
 */

/*题解思路： 已知：两数相等异或结果为0，一个数与0异或结果就等于其本身。
所以如果数组中只有一个出现一次的数，那么就只需要对所有的数进行异或就可以得到这个只出现一次的数，而本题中出现一次的数有两个。
所以所有数异或的结果就是那两个只出现一次的数异或的结果。所以根据这个特性，我们就可以采用分组的方法解决此问题。且分组要满足两个条件。
1、两个相同的数必须出现在同一组。2、那两个只出现一次的数必须分配在不同的组。这样我们分别对这两组数进行异或，就可以得到两个出现一次的数。
那么，究竟应该怎么分组呢？ 例如【4,1,4,6】:全部异或的结果就是1和6异或的结果。就是0001和0110异或的结果0111。
其实我们不难发现。将该两个相同的数分配在一组是很容易实现的。我们只需要固定一个二进制位，若这两个数在这个二进制位上的数是相同的。
我们就把他分在同一组。但是难点还是在如何实现将两个子出现一次的数分配在不同的组里面。
往下分析，1和6异或结果就是0111，0111这个二进制数中是1的二进制位暗含了什么个意思呢？分析不难知道，二进制位是1，就表示1和6在这个二进制位上的数是不同的。
所以，这就是我们划分两个数到不同组的依据。因为0111有三个二进制位都是1，分别是第一位、第二位、第三位。这就表示了1和6的二进制数在第一、二、三位上的数是不同的。
我们假设就以第一个二进制位为划分标准。当数组中的数的第一个二进制位是1的就分为第一组。数组中的数第一个二进制位是0的就划分为第二组。
这样就成功的将1和6分到了不同的组别中，而相同的数例如4，因为4和4的第一个二进制位是必然相等的，这样也就实现了将两个相同的数划分到同一组。
最后只需要分别将这两个组进行异或，就可以得到我们要求的答案。*/
var singleNumbers = function (nums) {
    let ret = 0;
    for (const x of nums) {
        ret ^= x;//ret最终答案就是那两个只出现一次的的数异或的结果
    }
    //找到ret二进制数中第几位是1，证明这两个数在这个位置的二进制不一样，所以可以在这里区分两个数
    let target = 1;//初始位0001
    while ((ret & target) == 0) {//如果target第一个二进制位不为1，就将target左移一位位0010，然后与相与，判断ret第二位是否为一.按此循环，知道找到ret的第一个为1的二进制位
        target = target << 1;
    }
    let a = 0,
        b = 0;
    for (const num of nums) {
        if ((num &target) == 0) {//第一组
            a ^= num;
        } else {//第二组
            b ^= num;
        }

    }

    return [a, b];

};

var singleNumbers = function (nums) {
    let x = 0;
    for (const val of nums) {
        x ^= val;//ret最终答案就是那两个只出现一次的的数异或的结果
    }
      // x & (-x)本身的作用是得到最低位的1，
      let flag = x & (-x); //结果是比如1  10  100  1000等
      // 而我们所需要的做到的是：利用这个1来进行分组，也就是做到将A和B区分开
      // 前面已经知道，x是我们需要的结果数A和B相异或的结果，也就是说，x的二进制串上的任何一个1，都能成为区分A和B的条件
      // 因此我们只需要得到x上的任意一个1，就可以做到将A和B区分开来
      let res = 0; // 用于记录A或B其中一者
      // 分组操作
      for (const val of nums) {
          // 根据二进制位上的那个“1”进行分组
          // 需要注意的是，分组的结果必然是相同的数在相同的组，且还有一个结果数
          // 因此每组的数再与res=0一路异或下去，最终会得到那个结果数A或B
          // 且由于异或运算具有自反性，因此只需得到其中一个数即可
          if ((flag & val) != 0) {
              res ^= val;
          }
      }
      // 利用先前的x进行异或运算得到另一个，即利用自反性
    return [res, x^res];

};

// nums = [1,2,10,4,1,4,3,3]
// a^a=0
// a^0=a
// a^b^c=a^c^b
// a&(-a)=最低位为1的二进制（从又到左）不能说是最低位的1的位置，而是最低位的1+后面的0组成的二进制数，原因就是负数的二进制取反后加了个1
// 负数的二进制表示，取反加1。 比如之前是 1取反后成了0，再+1，又成了1，这样一对相反数按位取与就可以把这个1与出来了 相反的，0取反的1，再+1，就进位了，这样本位变成了0，一对相反数按位取与在这个位置就得不到1，只会在原码第一次出现1的位置与出1 不知道我解释明白了没有
// 所有的异或结果得到sum=2^10=8
// flag=-8&8=8
// 可分为两组，一组为与flag相与等于1的[10]，另一组为0的[1,2,4,1,4,3,3]
// 组内异或分别得到【10】【2】

var singleNumbers = function (nums) {
    let sum=0;
    //得到异或结果，即为不相同两个数的异或结果sum
    for(const num of nums)
        sum^=num;
    //得到sum的二进制的1的最低位
    let flag=(-sum)&sum;
    let a=0,b=0;
    //分成两个组进行异或，每组异或后的结果就是不相同两个数的其中之一
    for(const num of nums){
        if((flag&num)==0)
            a^=num;
        else{
            b^=num;
        }
    }
    return [a,b];
}
